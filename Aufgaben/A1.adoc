:imagesdir: img

= A technical comparison of DIDComm and OIDC

== Was ist OIDC?
* einfachte Identitäts Layer über dem OAuth 2.0 Protokoll
* Ermöglicht es dem Client, Endbenutzer zu identifizieren und einfache Informationen über ihn zu erhalten.
* alle Arten von Clients sind möglich

.Wie funktioniert OIDC?
image::IMG_0019.jpg[]

OIDC steht für OpenID-Connect und ist ein Service zur Authentifizierung von Usern anhand bestimmter "flows". In OIDC werden 3 Endpunkte benötigt um die Authentifizierung durchzuführen. Diese Endpunkte sind: ein Authentifizierungsserver (OpenID Connect Provider), der Client(OpenID Connect Application) und der Endnutzer. 
Möchte der User nun einer Website ermöglichen seine Daten von einem Authentifierungsserver zu holen, so muss er sich auf dem Server zuerst Authentifizieren & Autorisieren. 
Sind beide Schritte erledigt, kann er Übergabe seiner Daten an den Client zustimmen. Die erhaltenen Daten müssen vor der Abfrage schon beschrieben sein, dies geschieht in Form eines Claims. 
OpenID Connect Provider: returns access_token and ID_token 
access_token = benötigt der Client um später auf den UserInfo Endpoint zuzugreifen, da dieser geschützt wird. 
ID_token = dient zur Authentifizierung, sollte aber keine größeren Informationen enthalten 
Ist der Prozess ist der Nutzer beim Client bekannt, somit weiß die Applikation es handelt sich um die Daten einer echten Entität. Werden noch weitere Informationen des Users benötigt müssen weitere UserInfo Requests versendet werden. 
User: Muss sich nur beim Server anmelden
OpenID Connect Appplication: 
Nutzung des access_tokens(opaque strings oder JWT) bei UserInfo Requests um zu beweisen, dass er zur Abfrage weiterer Credentials des Users berechtigt ist -> Zugriff auf API + legt scope für "initiale" Abfrage fest; Credentials aus dem Claim welcher gleich zum Anfang gesendet wird, werden in form des id_tokens zurückgesendet
ID_token(JWT) -> nutzen um ersten Credentials des Users zu haben; signiert mit JWS 

Bsp. für id_token: 
{
  "iss": "http://my-domain.auth0.com",
  "sub": "auth0|123456",
  "aud": "my_client_id",
  "exp": 1311281970,
  "iat": 1311280970,
  "name": "Jane Doe",
  "given_name": "Jane",
  "family_name": "Doe",
  "gender": "female",
  "birthdate": "0000-10-31",
  "email": "janedoe@example.com",
  "picture": "http://example.com/janedoe/me.jpg"
}

Bsp. für access_token: 
{
  "iss": "https://my-domain.auth0.com/",
  "sub": "auth0|123456",
  "aud": [
    "https://example.com/health-api",
    "https://my-domain.auth0.com/userinfo"
  ],
  "azp": "my_client_id",
  "exp": 1311281970,
  "iat": 1311280970,
  "scope": "openid profile read:patients read:admin"
}

-> beide token werden per JWS (JSON web keys) verschlüsselt  
{
    "alg": "RS256",
    "kid": "9ac7441d-1c47-49ad-9bb9-740d0f6a1702",
    "typ": "JWT"
}

== Was ist DIDComm?
//source: https://www.windley.com/archives/2020/11/didcomm_and_the_self-sovereign_internet.shtml
//https://medium.com/decentralized-identity/understanding-didcomm-14da547ca36b
* DIDComm ist ein Nachrichtenprotokoll für DID (Decentralized Identifiers) basierte Dienste / Kommunikationsverbindungen
** diese Verbindungen sind der Kern von SSI
* allgemeines Protokoll, welches durch anwendungsspezifische Besonderheiten ergänzt werden kann -> diese Spezifikation wird dann erst in der Softwareebene ausgewertet, DIDComm bietet nur einen Dienst wie die Nachrichten ausgetauscht werden können 
* hat keine spezifischen Vorgaben zur Implementierung, sondern kann für jede SSI-Interaktion verwendet werden -> bildet Grundlage/einen Standard
* zum Datentausch werden nur die DID des  jeweils anderen Users benötigt
** beide Kommunikationspartner sind selbst zertifiziert und sind sich einig über die gegenseitige Authentizität
* DIDComm = "Grundlage"; DIDComm Protocols = "Was soll in der Kommunikation ausgetauscht werden?" -> vergleichbar mit HTTPS und API's welche im Web geschrieben werden, sind unabhängig voneinander, aber API's ohne HTTPS funktionieren nicht, DIDComm Protocols funktionieren ohne DIDComm genauso wenig 

.Eigenschaften von DIDComm
* sicher
* privat
* interoperabel
* Art der Verbindung ist unwichtig
* erweiterbar

* kein bestimnmtes Betriebssystem, Progrtammiersprache, Anbieter, Netzwerk oder hardware
* Ziel ist es, die standardmäßige Kommunikation bei sicheren, privaten Interaktionen im und außerhalb des Internets zu werden
* es können alle Arten von Verbindungen genutzt werden _(HTTP(s), Websockets, IRC, Bluetooth, NFC, Signal, email, push benachrichtigungen, etc.)_

== Beispiele für OIDC und DIDComm

* Workflow von OIDC und DIDComm darstellen
OIDC Workflow: 
Die Flows dienen in diesem Fall zur Beschreibung der Übertragung der Token an den Client. Dabei unterscheidet man den Implicit Flow, den Authorization Code Flow & den Hybrid Flow. 
Authorization Code Flow: 
Sollte verwendet werden wenn serverseitig secrets gespeichert werden können.
GET-Request des Clients welcher User zum authorization endpoint weiterleitet
Location: domain-des-endpoints/authorize?
          client_id=abc&
          response_type=code&
          scope=openID_scope&
          redirect_uri=redirect_to_Client
-> An authorization-endpoint angekommen, Nutzer muss sich einloggen & bestätigen dass Daten weitergegeben werden dürfen
-> Endpoint erzeugt redirect: domain/login?
                              provider=<endpoint>
                              state=12345&
                              code=issuecode

Client muss authorization code nehmen um access_token zu erhalten 
POST-Request an domain/token
                client_id=abc&
                client_secret=secret&
                grant_type=authorization_code&
                code=issuecode

Endpoint answer: 
"access_token":"access_token",
"refresh_token":"refresh_token",
"expires_in":36000,
"scope":"granted_scope",
"id_token":"idtoken"

userinfo endpoint kann nun mit access_token aufgerufen werden und Daten werden abgerufen

Antwort: "sub":"abc",
         "name":"Pascal",
         "username":"testUser"

Implicit Flow: 
Client: GET /authorize?
            response_type=token&
            scope=openid mail name&
            client_id=123&
            state=abc&
            redirect_uri=client&
            nonce=<random string>

Endpoint: Location /redirect_uri#access_token=anAccessToken& -> access_token wird als fragment angelegt & bleibt somit im Browser
                                 expires_in=36000&
                                 state=abc&
                                 id_token=eyJ&
                                 refresh_token=avc&
                                 token_type=bearer
                                 
Client: kann nun protected ressources wie zB userinfo endpoint anfragen 

DIDComm workflow: 
DIDComm ist ein Nachrichtenformat, orientiert an dem Konzept für Emails, bei dem zwischen 2 Entitäten eine Verbindung besteht, welche 2 Kanäle beinhaltet. Kanal A, für Nachrichten von Alice zu Bob. Kanal B,
für Nachrichten von Bob zu Alice. Die Nachrichten können dabei aufeinander aufbauend, als Antworten, oder unabhängig voneinander versendet werden. 
Man unterscheidet zwischen 3 Nachrichtenformaten: Plaintext, optinal JWS envelope, JWE envelope
DIDComm Plaintext message: 
Nachricht welche ohne jegliche Verschlüsselung übermittelt wird.
DIDComm signed message: 
Handelt sich dabei um eine signierte JWM(JSON web message). Dies ist ein gängiges Format um Nachrichten über verschiedenste Protokolle zu übertragen, welche per JWE(JSON web encryption) gesichert wird.
DIDComm encrypted message: 
Verschlüsselte JWM. 

DIDComm Message Plaintext Beispiel
{
  "id": "1234567890",
  "type": "<message-type-uri>",
  "from": "did:example:alice",
  "to": ["did:example:bob"],
  "created_time": 1516269022,
  "expires_time": 1516385931,
  "body": {
    "message_type_specific_attribute": "and its value",
    "another_attribute": "and its value"
  }
} -> data stored in JSON body

Was muss gegeben sein um 2 Agents miteinander sprechen zu lassen? 
- serviceEndpoint -> deklariert wie andere Entität sie erreichen kann; besteht aus Set von DIDComm Service Endpoint URI's (wie will der owner seine Nachrichten empfangen), zB 
{
    "id": "did:example:123456789abcdefghi#didcomm-1",
    "type": "DIDCommMessaging",
    "serviceEndpoint": [{
        "uri": "https://example.com/path",
        "accept": [
            "didcomm/v2", -> welche Typen werden von Aussteller akzeptiert?
            "didcomm/aip2;env=rfc587"
        ],
        "routingKeys": ["did:example:somemediator#somekey"]
    }]
}
- Sicherheit -> DIDComm Message wird immer mit Schlüsseln der empfangenden DID verschlüsselt; gleiche Nachricht an mehrere Sender muss mehrfach verschlüsselt werden (authcrypt / anoncrypt)

DIDComm Rollen:
sender - 
mediator - 
empfänger - 

Nachrichtenaustausch von Alice & Bob
Alice -> auflösen des DID Documents von Bob 
      -> erhalt von Bob's public key & Adresse auf welche Art & Weise Bob Nachrichten empfangen kann
      -> verschlüsseln Plaintext durch Alice mit public key Bob & eigenem private key
(DIDComm Routing)
Bob   -> empfangen der Nachricht & entschlüsseln + Alice als Sender authentifizieren (Alice's DID Document abrufen)
      -> (vorbereiten einer Antwort + versendet)

MessageURI -> id, thid, pthid kombinieren um DIDMessage eindeutig erkennbar zu machen (unique)
id = Nachrichten ID
thid = Thread ID
pthid = Parent_Thread ID 

Transportvoraussetzungen: 
    format of serviceEndpoint uri: Which URI schemes are used (if URI), or the properties of the object (if object).
    how to actually send messages: e.g., through HTTPS POST, through dial protocol (libp2p), etc.
    how IANA media types of the content are provided, e.g., through Content-Type header, etc.
    where additional context definition is hosted, e.g., in case the serviceEndpoint object has extra properties specific to the transport.

Routing Protocol 2.0 vereinfacht dass senden von Nachrichten
-> Partie muss immer nur den nächsten hop & Ziel kennen, gesamter Pfad den Nachricht gegangen ist kennt keiner 




** Teilnehmer erklären
- OpenID Provider ist ein eingerichteter Endpoint welcher sich um die Authentifizierung der User kümmert, eine Schnittstelle für token, authentifizierung & userinfo


* Technischen Vergleich


Quellen: 
https://identity.foundation/didcomm-messaging/spec
