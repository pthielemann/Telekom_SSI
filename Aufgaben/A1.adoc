:imagesdir: img

= A technical comparison of DIDComm and OIDC

== OIDC (OpenID Connect)

=== Was ist OIDC?

OpenID Connect ist ein Authentifizierungsprotokoll und eine Erweiterung des OAuth 2.0 Standards. Es ermöglicht Clients die Überprüfung der Identität des Endbenutzers auf der Grundlage der von einem Autorisierungsserver durchgeführten Authentifizierung sowie den Erhalt grundlegender Profilinformationen über den Endbenutzer in einer interoperablen und REST-ähnlichen Schnittstelle. Mit OpenID Connect können Clients aller Art, einschließlich webbasierter, mobiler und JavaScript-Clients, Informationen über authentifizierte Sitzungen und Endbenutzer anfordern und empfangen.

Bei einer OpenID-Connect-Anfrage wird der Benutzer an einen Identitätsanbieter wie zb. Google oder Facebook weitergeleitet, der die angeforderten Informationen authentifiziert und autorisiert und dann mit einem ID-Token und optional einem Zugriffstoken an die anfordernde Anwendung (zb. eine App) zurückgeschickt.

NOTE: *Authentifizierung:* "Wer bist du?"

NOTE: *Authorizierung:* "Bist du berechtigt das zu tun?"

*UseCase:* SSO (Single Sign-On) für Konsumenten Apps

=== Die Teilnehmer bei OIDC

//image::img/IMG_0019.jpg[]

In OIDC werden 4 Teilnehmer benötigt um eine Authentifizierung durchzuführen. Diese Teinehmer sind der Identity Provider (IdPs), die Relying Parties (RPs) und die OpenID Providers (OPs).

* *Identity Providers (IdPs):* Ein IdP ist ein Dienst (zb. Google oder Facebook), der Benutzer authentifiziert und Identitäts-Token ausstellt, wie z. B. ein OpenID Connect ID Token. Der IdP ist für die sichere Authentifizierung von Benutzern sowie für die Verwaltung und den Schutz ihrer Identitäten verantwortlich.

* *Relying Parties (RPs):* Ein RP ist ein Dienst/Client (zb. eine App), der sich auf den IdP verlässt, um seine Benutzer zu authentifizieren. Der RP ist dafür verantwortlich, die Identitäts-Token vom IdP zu verbrauchen, um seine Benutzer zu identifizieren.

* *OpenID Providers (OPs):* Ein OP ist ein Dienst, der eine OpenID Connect-Schnittstelle zum IdP und RP bereitstellt. Der OP ist verantwortlich für die sichere Bereitstellung der notwendigen Protokoll- und Kommunikationsinfrastruktur, um den Authentifizierungsprozess zu erleichtern.

* *Resource Owner (RO):* Ein RO ist die Entität, die den Zugriff auf eine geschützte Ressource (zb. Personeninformationen) gewährt, z.B. ein Endnutzer. Der RO ist für die Autorisierung des Zugriffs auf die Ressource verantwortlich und kann entweder der Endbenutzer selbst oder eine Entität sein, der die Autorität übertragen wurde, im Namen des Endbenutzers handeln zu dürfen.

=== Der OIDC Ablauf

*Schritt 1:* Ein Endbenutzer (Resource Owner) besucht eine Website (Relying Partie), die OpenID Connect unterstützt und klickt auf eine Schaltfläche "Anmelden".

*Schritt 2:* Die Webseite (auch Client genannt) leitet den Endbenutzer an den OpenID Provider (OP), häufig gleichzeitig auch der Identity Provider, mit einer Anfrage zur Authentifizierung des Benutzers weiter.

*Schritt 3:* Der OP authentifiziert den Benutzer, indem er ihn auffordert, seinen Benutzernamen und sein Passwort einzugeben. Dabei müssen die Daten die angefordert werden, bereits vor der Abfrage beschrieben sein.

*Schritt 4:* Nach erfolgreicher Authentifizierung sendet der OP eine Authentifizierungsantwort an die Website mit einem ID-Token und einem Access Token.

*Schritt 5:* Die Website überprüft das ID-Token, um sicherzustellen, dass es gültig ist und dass der Benutzer derjenige ist, der er vorgibt zu sein.

*Schritt 6:* Die Website kann nun das Access Token verwenden, um im Namen des Benutzers API-Aufrufe an den OP zu tätigen.

*Schritt 7:* Die Website kann nun dadurch dem Nutzer ein personalisiertes Erlebnis auf der Website bieten.

==== Erweiterung des OAuth 2.0 Authorization Request

Der *OAuth 2.0 Authorization Request* wird um den Parameter *Scope* erweitert. Hiermit kann festgelegt werden, auf welche Informationen des Benutzers der Client zugreifen darf. Diese Informationen werden in Form eines Claims zurückgesendet.

NOTE: *Scope:* Ein Scope (Geltungsbereich) ein Satz von Regeln zur Bestimmung des Umfangs der Sichtbarkeit oder Zugänglichkeit einer Abfrage.

NOTE: *Claims:* Aussagen über einen Benutzer, die im ID-Token zurückgegeben werden. Diese Angaben können den Namen des Benutzers, seine E-Mail-Adresse und andere Informationen über den Benutzer wie Alter, Geschlecht oder Standort enthalten. Die Angaben sind in einem JSON Web Token (JWT) kodiert und werden nach erfolgreicher Authentifizierung an die Client-Anwendung gesendet.

==== ID-Token

Ein ID-Token ist ein Token der verwendet wird, um einen Endbenutzer zu identifizieren. Es handelt sich dabei um ein signiertes und optional verschlüsseltes Datenelement, das *Informationen über den Benutzer* enthält, wie z.B. den Namen, die E-Mail-Adresse und andere identifizierende Merkmale. ID-Tokens werden zur Authentifizierung des Benutzers für eine einzige Sitzung verwendet.

Bsp. für einen ID-Token
----
{
  "iss": "http://my-domain.auth0.com",
  "sub": "auth0|123456",
  "aud": "my_client_id",
  "exp": 1311281970,
  "iat": 1311280970,
  "name": "Jane Doe",
  "given_name": "Jane",
  "family_name": "Doe",
  "gender": "female",
  "birthdate": "0000-10-31",
  "email": "janedoe@example.com",
  "picture": "http://example.com/janedoe/me.jpg"
}
----

==== Access Token

Ein Zugriffstoken ist ein Token der verwendet wird, um den Zugriff auf eine API oder Ressource zu gewähren. Es handelt sich um ein signiertes und optional verschlüsseltes Datenelement, das *Informationen über den Client und den Ressourcenserver* sowie eine *Berechtigungserteilung* enthält. Zugriffstoken werden für den Zugriff auf geschützte Ressourcen im Namen eines autorisierten Benutzers verwendet.

Bsp. für einen Access Token
----
{
  "iss": "https://my-domain.auth0.com/",
  "sub": "auth0|123456",
  "aud": [
    "https://example.com/health-api",
    "https://my-domain.auth0.com/userinfo"
  ],
  "azp": "my_client_id",
  "exp": 1311281970,
  "iat": 1311280970,
  "scope": "openid profile read:patients read:admin"
}
----

=== JSON Web Tokens

JWT unterstützt die kryptographische Signatur  und optional die Verschlüsselung. Es kann sowohl für Access und Refresh Tokens als auch zum Informationsaustausch verwendet werden. In OpenID Connect wird es genutzt, um Benutzerinformationen sicher zu übertragen.

Zum Beispiel repräsentiert das folgende Token
----
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
----

nachstehenden JSON-Inhalt
----
Header: 
{
    "alg": "HS256",
    "typ": "JWT"
}
Payload:
{
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022
}
----

Der Header gibt Auskunft über Signatur- oder Verschlüsselungsalgorithmus, sowie den Typ des Tokens. Die einzelnen Einträge im Payload sind Claims.

NOTE: *sub:* Steht für den Subject Identifier, d.h. die Instanz auf die sich das JWT bezieht. 

NOTE: *iat:* Representiert den Ausstellungszeitpunkt („Issued At“)

=== Implementierungsbeispiel für OIDC (JavaScript)

----
// Initial OIDC setup (for authentication and authorization)
const { OIDCStrategy } = require('passport-azure-ad');

const oidcStrategy = new OIDCStrategy(
    {
        // Provide the OIDC client ID and secret
        clientID: '<client-id-here>',
        clientSecret: '<client-secret-here>',
        callbackURL: 'https://localhost:3000/auth/openid/callback',

        // Provide the OIDC scope
        scope: ['openid'],

        // Provide the OIDC identity provider
        issuer: 'https://login.microsoftonline.com/<tenant-id-here>/v2.0',
    },
    (iss, sub, profile, accessToken, refreshToken, done) => {

        // User authentication and authorization logic
        if (profile.oid === '<user-id-here>') {
            return done(null, profile);
        }

        return done(null, false);
    }
);

// Passport registration
const passport = require('passport');
passport.use(oidcStrategy);

// Express middleware setup
const express = require('express');
const app = express();

// Setup the authentication routes
app.use(passport.initialize());

// Login route
app.get('/login', passport.authenticate('azuread-openidconnect', {
    failureRedirect: '/error',
}), (req, res) => {
    res.redirect('/');
});

// Callback route
app.get('/auth/openid/callback', passport.authenticate('azuread-openidconnect', {
    failureRedirect: '/error',
}),
(req, res) => {
    res.redirect('/');
});

// Error route
app.get('/error', (req, res) => {
    res.send('Authentication error!');
});

// Serve the application
app.listen(3000, () => {
    console.log('Application is running on port 3000');
});
----

////
Quellen:
1. https://www.oose.de/blogpost/oauth-openid-connect-und-jwt-wie-haengt-das-alles-zusammen-teil-1/
2. https://www.oose.de/blogpost/oauth-openid-connect-und-jwt-wie-haengt-das-alles-zusammen-teil-2/
////








== Was ist DIDComm?
//source: https://www.windley.com/archives/2020/11/didcomm_and_the_self-sovereign_internet.shtml
//https://medium.com/decentralized-identity/understanding-didcomm-14da547ca36b
* DIDComm ist ein Nachrichtenprotokoll für DID (Decentralized Identifiers) basierte Dienste / Kommunikationsverbindungen
** diese Verbindungen sind der Kern von SSI
* allgemeines Protokoll, welches durch anwendungsspezifische Besonderheiten ergänzt werden kann -> diese Spezifikation wird dann erst in der Softwareebene ausgewertet, DIDComm bietet nur einen Dienst wie die Nachrichten ausgetauscht werden können 
* hat keine spezifischen Vorgaben zur Implementierung, sondern kann für jede SSI-Interaktion verwendet werden -> bildet Grundlage/einen Standard
* zum Datentausch werden nur die DID des  jeweils anderen Users benötigt
** beide Kommunikationspartner sind selbst zertifiziert und sind sich einig über die gegenseitige Authentizität
* DIDComm = "Grundlage"; DIDComm Protocols = "Was soll in der Kommunikation ausgetauscht werden?" -> vergleichbar mit HTTPS und API's welche im Web geschrieben werden, sind unabhängig voneinander, aber API's ohne HTTPS funktionieren nicht, DIDComm Protocols funktionieren ohne DIDComm genauso wenig 

.Eigenschaften von DIDComm
* sicher
* privat
* interoperabel
* Art der Verbindung ist unwichtig
* erweiterbar

* kein bestimnmtes Betriebssystem, Progrtammiersprache, Anbieter, Netzwerk oder hardware
* Ziel ist es, die standardmäßige Kommunikation bei sicheren, privaten Interaktionen im und außerhalb des Internets zu werden
* es können alle Arten von Verbindungen genutzt werden _(HTTP(s), Websockets, IRC, Bluetooth, NFC, Signal, email, push benachrichtigungen, etc.)_

== Beispiele für OIDC und DIDComm

* Workflow von OIDC und DIDComm darstellen
OIDC Workflow: 
Die Flows dienen in diesem Fall zur Beschreibung der Übertragung der Token an den Client. Dabei unterscheidet man den Implicit Flow, den Authorization Code Flow & den Hybrid Flow. 
Authorization Code Flow: 
Sollte verwendet werden wenn serverseitig secrets gespeichert werden können.
GET-Request des Clients welcher User zum authorization endpoint weiterleitet
Location: domain-des-endpoints/authorize?
          client_id=abc&
          response_type=code&
          scope=openID_scope&
          redirect_uri=redirect_to_Client
-> An authorization-endpoint angekommen, Nutzer muss sich einloggen & bestätigen dass Daten weitergegeben werden dürfen
-> Endpoint erzeugt redirect: domain/login?
                              provider=<endpoint>
                              state=12345&
                              code=issuecode

Client muss authorization code nehmen um access_token zu erhalten 
POST-Request an domain/token
                client_id=abc&
                client_secret=secret&
                grant_type=authorization_code&
                code=issuecode

Endpoint answer: 
"access_token":"access_token",
"refresh_token":"refresh_token",
"expires_in":36000,
"scope":"granted_scope",
"id_token":"idtoken"

userinfo endpoint kann nun mit access_token aufgerufen werden und Daten werden abgerufen

Antwort: "sub":"abc",
         "name":"Pascal",
         "username":"testUser"

Implicit Flow: 
Client: GET /authorize?
            response_type=token&
            scope=openid mail name&
            client_id=123&
            state=abc&
            redirect_uri=client&
            nonce=<random string>

Endpoint: Location /redirect_uri#access_token=anAccessToken& -> access_token wird als fragment angelegt & bleibt somit im Browser
                                 expires_in=36000&
                                 state=abc&
                                 id_token=eyJ&
                                 refresh_token=avc&
                                 token_type=bearer
                                 
Client: kann nun protected ressources wie zB userinfo endpoint anfragen 

DIDComm workflow: 
DIDComm ist ein Nachrichtenformat, orientiert an dem Konzept für Emails, bei dem zwischen 2 Entitäten eine Verbindung besteht, welche 2 Kanäle beinhaltet. Kanal A, für Nachrichten von Alice zu Bob. Kanal B,
für Nachrichten von Bob zu Alice. Die Nachrichten können dabei aufeinander aufbauend, als Antworten, oder unabhängig voneinander versendet werden. 
Man unterscheidet zwischen 3 Nachrichtenformaten: Plaintext, optinal JWS envelope, JWE envelope
DIDComm Plaintext message: 
Nachricht welche ohne jegliche Verschlüsselung übermittelt wird.
DIDComm signed message: 
Handelt sich dabei um eine signierte JWM(JSON web message). Dies ist ein gängiges Format um Nachrichten über verschiedenste Protokolle zu übertragen, welche per JWE(JSON web encryption) gesichert wird.
DIDComm encrypted message: 
Verschlüsselte JWM. 

DIDComm Message Plaintext Beispiel
{
  "id": "1234567890",
  "type": "<message-type-uri>",
  "from": "did:example:alice",
  "to": ["did:example:bob"],
  "created_time": 1516269022,
  "expires_time": 1516385931,
  "body": {
    "message_type_specific_attribute": "and its value",
    "another_attribute": "and its value"
  }
} -> data stored in JSON body

Was muss gegeben sein um 2 Agents miteinander sprechen zu lassen? 
- serviceEndpoint -> deklariert wie andere Entität sie erreichen kann; besteht aus Set von DIDComm Service Endpoint URI's (wie will der owner seine Nachrichten empfangen), zB 
{
    "id": "did:example:123456789abcdefghi#didcomm-1",
    "type": "DIDCommMessaging",
    "serviceEndpoint": [{
        "uri": "https://example.com/path",
        "accept": [
            "didcomm/v2", -> welche Typen werden von Aussteller akzeptiert?
            "didcomm/aip2;env=rfc587"
        ],
        "routingKeys": ["did:example:somemediator#somekey"]
    }]
}
- Sicherheit -> DIDComm Message wird immer mit Schlüsseln der empfangenden DID verschlüsselt; gleiche Nachricht an mehrere Sender muss mehrfach verschlüsselt werden (authcrypt / anoncrypt)

DIDComm Rollen:
sender - 
mediator - 
empfänger - 

Nachrichtenaustausch von Alice & Bob
Alice -> auflösen des DID Documents von Bob 
      -> erhalt von Bob's public key & Adresse auf welche Art & Weise Bob Nachrichten empfangen kann
      -> verschlüsseln Plaintext durch Alice mit public key Bob & eigenem private key
(DIDComm Routing)
Bob   -> empfangen der Nachricht & entschlüsseln + Alice als Sender authentifizieren (Alice's DID Document abrufen)
      -> (vorbereiten einer Antwort + versendet)

MessageURI -> id, thid, pthid kombinieren um DIDMessage eindeutig erkennbar zu machen (unique)
id = Nachrichten ID
thid = Thread ID
pthid = Parent_Thread ID 

Transportvoraussetzungen: 
    format of serviceEndpoint uri: Which URI schemes are used (if URI), or the properties of the object (if object).
    how to actually send messages: e.g., through HTTPS POST, through dial protocol (libp2p), etc.
    how IANA media types of the content are provided, e.g., through Content-Type header, etc.
    where additional context definition is hosted, e.g., in case the serviceEndpoint object has extra properties specific to the transport.

Routing Protocol 2.0 vereinfacht dass senden von Nachrichten
-> Partie muss immer nur den nächsten hop & Ziel kennen, gesamter Pfad den Nachricht gegangen ist kennt keiner 




** Teilnehmer erklären
- OpenID Provider ist ein eingerichteter Endpoint welcher sich um die Authentifizierung der User kümmert, eine Schnittstelle für token, authentifizierung & userinfo


* Technischen Vergleich


Quellen: 
https://identity.foundation/didcomm-messaging/spec
