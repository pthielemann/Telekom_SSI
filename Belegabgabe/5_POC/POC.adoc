== Proof-of-Concept (SSI)

Um das Konzept von SSI in seiner Machbarkeit und seinem Potenzial zur Umsetzung zu belegen, wollen wir eine eine praktische Demonstration dieser Technologie umsetzen. Es handelt sich dabei um einen einfache experimentellen Ansatz, um die Funktionsfähigkeit dieses Konzeptes zu testen. Der Zweck dieses PoC ist es, ein besseres Verständnis für die technischen und geschäftlichen Auswirkungen von SSI zu gewinnen.

Dazu wird das Hyperledger Aries Framework verwendet. Es ist eine Bibliothek von Protokollen, Formaten und Komponenten, die es Entwicklern erleichtern, Anwendungen für Verifiable Credentials und die Übertragung von Informationen in einer SSI-Umgebung zu erstellen. Das Framework basiert auf dem DIDComm Protokoll und beinhaltet dessen technologischen Umsetzung.

Hyperledger Aries unterstützt zudem eine Vielzahl von Identity-Systemen, einschließlich Decentralized Identifier (DID) und Verifiable  Credentials. Es bietet eine einheitliche API für die Übertragung von Daten zwischen verschiedenen Identity-Systemen, die Interoperabilität und Austauschbarkeit gewährleisten. Das Hyperledger Aries-Framework bietet auch Funktionen wie Identitätsmanagement, Übertragung von Daten, Schlüsselverwaltung und mehr, die für die Entwicklung von Anwendungen erforderlich sind, die auf SSI basieren.

Um das Ganze anschaulicher zu Demonstrieren, wollen dazu die https://github.com/hyperledger/aries-cloudagent-python/blob/main/demo/AliceGetsAPhone.md[Alice Gets a Mobile Agent!] Demo von Hyperledger Aries verwenden. In dieser Demo werden wir 2 Standardszenarien simulieren.

=== Szenarien

(1.) *Das Ausstellen von Credentials*

Im ersten Szenario baut Alice eine Verbindung zu Ihrer Hochschule durch die Annahme einer Einladung in Form eines QR-Codes auf. Im zweiten Schritt sendet ihre die Hochschule Verifiable Credentials zu, welche das Datum ihres Abschlusses und das Studienfach beinhalten. Das Szenario ist im Folgenden nochmals als Ablauf grafisch dargestellt.

// Image 1 einfügen

(2.) *Verifizierung der Credentials*

Im zweiten Szenario möchte sich Alice bei einem neuen Arbeitgeber bewerben. Dazu muss sie nachweisen, dass sie tatsächlich über einen Abschluss in Mathematik verfügt. Ihr Arbeitgeber fordert Sie dazu auf, ihr Credentials zuzusenden. Alice kann den Umfang der geforderten Daten vorab einsehen und diese bestätigen. Ein *Selective Attribute Disclosure* wird in dieser Demo nicht gezeigt.

Diese Credentials werden wiederrum durch den Arbeitgeber, mit dem  Abgleich der DID der Hochschule als Issuer der Credetials aus dem Verifiable Data Register, verifiziert und bestätigt.

// Image 3 einfügen

=== Komponenten

Um beide Szenarien technisch umsetzen zu können, benötigen wir mehrere Komponenten, die wir erstellen und simulieren müssen.

Alice:: Damit wir Alice simulieren können, verwenden wir ein geeignetes Smartphone (iPhone 13) auf dem ein Wallet installiert ist, welches über seinen eigenen Agent kommuniziert.

Wallet/Agent:: Beim Wallet haben wir uns für das *esatus Wallet* entschieden. Esatus ist eine Eigenentwicklung der esatus AG, welche ein Treiber von Self-Sovereign Identity (SSI) in Deutschland und einer der globalen Technologieführer ist. Das Wallet bietet für die Demonstration folgenden Funktionsumfang:

. Das Scannen eines QR-Codes (Einladungen der Hochschule)
. Verbindungsaufbau zu einem anderen Agent (Hochschule/Arbeitgeber)
. Die Verwaltung von Verbindungen
. Die Möglichkeit ein Test-Ledger auszuwählen (BCGov Test Ledger/BCovrin)
. Das halten, speichern und vorzeigen von Credentials

-> Darüber hinaus werden auch noch weitere Funktionen angeboten, die wir im Umfang dieser Demonstration jedoch nicht betrachten werden.

Hochschule:: Damit wir unseren Issuer, die Hochschule, imulieren können, müssen wir diese als Agent lokal installieren und hosten. Der Agent verfügt dann über folgende Funktionen:

* Issue Credential
* Send Proof Request
* Send *Connectionless* Proof Request
* Send Message
* Create New Invitation
* Revoke Credential
* Publish Revocations
* Toggle tracing in credential/proof exchange

-> Für die Simulation verwenden wir hauptsächlich die ersten 2 Funktionen.

Arbeitgeber:: Der Arbeitgeber wird auf die gleiche Weise wie die Hochschule simuliert. Wir beschränken uns dabei auf *EINEN localhost*, welcher gleichzeitig Arbeitgeber und Hochschule simuliert. In einem Real Case Szenraio wären diese zwei getrennte Parteien. Der Issuer (Hochschule) und der Verifier (Arbeitgeber) der im OIDC Kontext die Reyling Party darstellt.

ngrok:: Ngrok ist ein Tunneling-Service, mit dem Entwickler lokale Anwendungen und Dienste über das Internet verfügbar machen können, ohne sie direkt bereitstellen zu müssen. Ngrok ermöglicht es, eine lokale Anwendung über eine öffentliche URL erreichbar zu machen, was beispielsweise für die Überprüfung von Anwendungen durch andere Benutzer oder das Debugging von Problemen nützlich sein kann. Wir verwenden Ngrok um ein Tunneling-Service nach außen für unseren localhost Agent für die *"Alice Gets a Mobile Agent!"* Demo zu bauen.

BCovrin (Ledger):: http://test.bcovrin.vonx.io[BCoverin] ist ein Test-Ledger (Verifiable Data Register), welches bei der Initiallisierung unserer *"Alice Gets a Mobile Agent" Anwendung als Ledger dient.

Indy Tails Server:: Indy Tails ist ein Projekt innerhalb der Hyperledger Indy Community, das sich auf die Bereitstellung von Anonymität und Datenschutz in der Identitätsbranche konzentriert. Ein https://github.com/bcgov/indy-tails-server[Indy Tails Server] ist ein Server, der Teil des Indy Tails-Projekts ist und Anwendern Anonymität bei der Verwendung von Hyperledger Indy-basierten Identitätslösungen bietet. Es handelt sich dabei um einen anonymen Proxy-Server, der eine Verbindung zwischen Anwendern und einer Hyperledger Indy-basierten Identitätslösung herstellt. Durch die Verwendung eines Indy Tails-Servers können Anwender ihre Identitätsdaten und ihre Online-Aktivitäten schützen, indem sie ihre echte Identität verborgen halten und stattdessen eine anonyme Identität verwenden.

*=> Daraus ergibt sich der folgender technische Aufbau*

// Image Technischer Aufbau

=== Technische Umsetzung

(1.) *Initialisierung Indy Tails Server*

Zuerst muss der Indy Tails Server initialisiert werden. Dazu wird ein Dockerimage gebaut, welches wiederum später von unserem lokalen Agent als Serverinstanz genutzt werden kann.

(2.) *Aufbau einer Bridge (ngrok)*

Um später lokal mit unserem Hochschul Agenten nach außen zu Alice kommunizieren zu können, müssen wir vorab über  ngrok ein http Bridge aufbauen. Dabei findet ein Portmapping des _localhost_ auf eine öffentliche URL statt.

    https://bf6a-2003-fa-af0a-25ad-a0ee-11e7-2b91.eu.ngrok.io -> http://localhost:8020

(3.) *Initialisierung des lokalen Agents*

Über das Tails Netzwerk wird ein Agent initialisiert, welcher wiederum BCovrin als Test Ledger nutzt. Der folgende Befehl zeigt die detaillierte Initialisierung des Agenten. 

    TAILS_NETWORK=docker_tails-server LEDGER_URL=http://test.bcovrin.vonx.io ./run_demo faber --aip 10 --revocation --events

Auflistung der Parameter:

TAILS_NETWORK=docker_tails-server:: Legt die Art des Tails-Netzwerks fest, auf dem das Demo ausgeführt wird. Hier wird "docker_tails-server" angegeben, so dass ein Docker-Container als Tails-Server verwendet wird.

LEDGER_URL=http://test.bcovrin.vonx.io:: Legt die URL des Ledger fest, mit dem Faber kommunizieren soll. Hier wird eine Test-URL angegeben, die auf einen vonx.io-Ledger-Server verweist.
/run_demo:: Ist der Befehl, der die Demo startet.

faber:: Ist das Argument, das an den Befehl übergeben wird und das Faber-System angibt, das Teil der Demos sein soll.

--aip 10:: Gibt an, dass das Demo gemäß den Anforderungen des AIP (Agent Interaction Protocol) 10 ausgeführt werden soll.

--revocation:: Gibt an, dass das Demo die Verwendung von Widerrufskomponenten beinhalten soll.

--events:: gibt an, dass das Demo die Überwachung von Ereignissen unterstützen soll.

(4.) *Installation des esatus Wallets*

Zuletzt müssen wir noch ein Wallet auf unserem Smartphone installieren. Die Installation findet klassich über den App-Store oder Play-Store statt. Dabei sind keine Spezifischkeiten zu beachten. Nach erfolgreicher Installation muss das Wallet auf das BCGov Test Ledger (BCovrin) umgestellt werden.

=== Ergebnis

Nachdem wir die technsichen Grundlagen für unsere Demonstration geschaffen haben, wollen wir zuletzt einen Auszug aus der *"Alice Gets a Mobile Agent!"* Demo zeigen.

(1.) *Start der ngrok Bridge*

image::./5_POC/img/ngrok.png[]

Zu erkennen ist vor allem das Mapping der lokalen Adresse _localhost:8020_ auf eine öffentlich zugängliche URL.

(2.) *Provisionierung eines Agents und einer Wallet*

image::./5_POC/img/start.png[]

Als nächstes wird der Tails Server gestartet und die Endpunkte des Servers mit ngrok gefetcht, so dass dieser einen neuen Endpunkt für die Kommunikation nach außen mit ngrok als Verbindungsbrücke erhält.

Danach werden wiederrum Agent und Wallet provisioniert, indem eine neue DID erzeugt wird, welche wiederum im Test Ledger (test.bcoverin) registriert wird.

(3.) *Erfolgreiche Provisionierung*

image::./5_POC/img/start.png[]

Nach erfolgreicher Provisionierung werden die Daten für den Agent und dem Wallet einschließlich der öffentlichen DID Information ausgegeben und gespeichert.

(4.) *Schema und weitere Einstellunge*

image::./5_POC/img/schema.png[]

Im Anschluss wird das Schema geladen, welches später für die Erzeugnung der Credentials verwendet wird. Es werden zusätzliche Konfigurationen abgeschlossen, die in dieser Darstellung jedoch nicht abgebildet sind.

(5.) *Erstellung einer Einladung*

image::./5_POC/img/schema.png[]

Nach erfolgreichen Abschluss aller Konfigurationen wird eine einmalige Einladung erstellt, die über einen mobilen Agenten (vorzugsweise den von Alice) gescannt werden kann. Danach hat Alice die Möglichkeit die Verbindung anzunehmen oder abzulehnen.

(6.) *Aufbau einer Verbindung zwischen Alice und dem Hochschul Agenten*

image::./5_POC/img/verbindung.png[]

Nachdem Alice die Einladung angenommen hat, wird eine Peer-to-Peer Verbindung zwischen dem Agenten von Alice und dem Agenten der Hochschule hergestellt.

(7.) *Austellung der Credentials*

image::./5_POC/img/issues.png[]

Sowohl Alice hat nun die Möglichkeit Credentials anzufordern, als auch die Hochschule besitzt die Möglichkeit diese eigenständig auszustellen. Dabei kann Alice die Korrektheit dieser Daten überprüfen und diese auch jederzeit ablehnen. Alice ist nicht dazu gezwungen die Credentials auch annehmen zu müssen. Damit behält Alice stets ihre Datenhohheit.

(8). *Speicherung der Credentials*

image::./5_POC/img/credentials.png[]

Die Credentials werden im eigenen persönlichen Wallet von Alice dezentral (aus Netzwerkperspektive) und zentral (aus ihrer eigenen Perspektive) gespeichert und sind dadurch lokal für Alice jederzeit abrufbar. 

(9.) *Überprüfung der Credentials*

image::./5_POC/img/credentials.png[]

Wichtig ist dabei vor allem die Überprüfung der Credentials. Dies geschieht durch dei Zertifizierung des Ausstellers. In diesem Demo Beispiel ist Aussteller (Issuer bzw. die Hochschule) und Verifizierer (Verifier bzw. der Arbeitgeber) ein und der selbe Agent. In einem Real-Case-Szenario findet die Verifizierug durch die Überprüfung der DID des Ausstellers im Daten Register (Ledger) statt.

=== Beurteilung

Das PoC stellt eine vereinfachte Implementierung von SSI dar. Das Grundkonzept wird damit veranschaulicht, jedoch werden nicht alle Parteien über verschiedene Agenten hinweg simuliert. Auch wird keine detaillierte Überprüfung der DID im Ledger aufgeführt, was wiederum ein wesentlicher Bestandteil für die Verifizierung von Credentials ist. Diese Vorgehensweise bleibt in einer Blackbox verborgen. Dennoch kann die Demo als ein Grundverständnis für die Vorgehensweise mit SSI genutzt werden.

Über das Hyperledger Aries Framework lassen sich weitere spezifischere Anforderungen implementieren, programmieren, erweitern und auf Real-Case-Szenrien anpassen. Dazu braucht es jedoch eine intensive Einarbeitung in das DIDComm Protokoll, ein tiefes Verständnis für SSI und einen starken technologischen Bachground. Die Implementierung von SSI ist daher wesentlich aufwendiger als das standardmäßige Arbeiten mit OICD, jedoch lohnen sich die Vorteile aus verschiedenen Perspektive.

Da nicht nur Personen von SSI profitieren können, sondern gleichermaßen auch Organisationen oder Objekte einen Vorteil dadurch SSI erhalten, wollen wir im letzten Abschnitt ein Szenario je Gruppe vorstellen, welches die Implementierung von SSI sinnvoll macht.

==== SSI für Personen

Die wesentlichen Vorteile für die Implementierung von SSI für Personen haben wir bereits ausführlich erläutert. Zusammenfassend lässt sich jedoch sagen, dass durch die Implementierung von SSI, Nutzer die Möglichkeit erhalten, ihre eigenen Daten eigenständig zu speichern, zu verwalten und nachweisen zu können, ohne das es die wiederholte Interaktion oder die Speicherung durch eine Dritte Partei benötigt. Ein solches Szenario wird in unserem PoC beschrieben.

==== SSI für Organisationen

Auch Unternehmen oder organisationen können von SSI profitieren. Ein Mögliches Szenario wäre zb. die Liefernanten Beziehung zweier Unternehmen, die zum derzeitigen Zeitpunkt noch keine Geschäftsbeziehung besitzen. Wie lässt sich digital die Echtheit und Glaubhaftigkeit eines Unternehmens, dass zb. im Ausland sitzt, überprüfen?

Auch können Unternehmen durch SSI ihre Echtheit, zb. beim Online-Shopping auf weniger Bekannten Webseiten oder Plattformen, nachweisen und somit Vertrauen gegenüber potentiellen Kunden gewinnen.

Ein weiterer Anwendungsfall wäre, dass dadurch eine Möglichkeit ensteht, wie Rechte von Unternehmen auf natürliche Personen übertragen werden können. Ein Bankvertreter kann sich somit zb. gegenüber einen Clienten oder als juristischer Vertreter seiner Instutition ausweisen.

==== SSI für Objekte

Das SSI Konzept lässt sich auch auf Objekte übertragen. Wann hat die letzte TÜV Prüfung stattgefunden? Wie ist die Lieferkette einer Maschine aufgebaut? Woher stammen die Rohstoffe oder Materialien? Durch SSI lassen sich all diese Punkte eindeutig durch verifizierbare Credentials nachweisen.

== Kritiken

Zuletzt wollen wir auch einige Kritiken an SSI und DIDComm äußern, die zum jetzigen Zeitpunkt noch teils ungelöst erscheinen.

*Der Verlust des Wallets*

Ein Wallet, das für SSI und DIDComm verwendet wird, speichert die Verifikations- und Kryptoschlüssel einer DID (Decentralized Identifier). Der Verlust des Wallets bedeutet in diesem Kontext den Verlust des Zugangs zu den Identitätsinformationen und den damit verbundenen Daten und Aktivitäten, die damit verknüpft sind. Dies kann für eine Person oder ein Unternehmen erhebliche Folgen haben, insbesondere wenn es sich um sensiblen oder vertraulichen Informationen handelt.

Dies ist ein möglicher Kritikpunkt von SSI und DIDComm, da der Verlust des Wallets eine Barriere für den Zugang zu den Identitätsinformationen darstellt und die Datensicherheit gefährdet.

*Weitere mögliche Kritikpunkte und Schwachstellen sind:*

* Interoperabilitätsprobleme: Obwohl es einen gemeinsamen Standard für DIDs und DIDComm-Nachrichten gibt, kann es Probleme bei der Interoperabilität zwischen verschiedenen Implementierungen und Plattformen geben.
* Datenschutzprobleme: Da DIDs und DIDComm-Nachrichten über ein dezentralisiertes Netzwerk übertragen werden, ist es schwierig, die Datenschutzrichtlinien und -anforderungen für verschiedene Anwendungen und Gerichtsbarkeiten einzuhalten.
* Skalierbarkeitsprobleme: Die Verarbeitung von DIDComm-Nachrichten und die Speicherung von DID-Informationen kann eine Herausforderung für dezentralisierte Netzwerke sein, die häufig nicht so leistungsstark wie zentralisierte Netzwerke sind.
* Benutzerfreundlichkeitsprobleme: Es kann schwierig sein, Benutzern ein einfaches und intuitives Verständnis von DIDs und DIDComm zu vermitteln, und die Verwendung von Wallets und anderen SSI-Tools kann für viele Benutzer eine Herausforderung darstellen